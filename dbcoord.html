---
layout: single
title: "Database"
author_profile: true
sidebar:
 nav: "languages"
---

<meta http-equiv="cache-control" content="no-cache">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

<div class="container">

  <p><a href="https://pwsmith.github.io/multivaluation/howtouse.pdf">How to use the database</a></p>

   <div class="table-responsive">
   <h2>Filters:</h2>
<div align="center">
  <style>
    button {background: transparent;
            font-size: 20px;
            font-weight: bold;
            border-color: #d59b40;
            border: 4;
            border-radius: 4px;
            border-style: solid;
            background-color: #d59b40;
            transition-duration: 0.2s;}
    button:hover {background-color: #d59b40;}
  </style>

  <table>
  <tr><th><label for="lang">Language:</label></th>
  <th><label for="langfam">Language Family:</label></th>
  <th><label for="feat">Agreement Feature:</label></th>
  <th><label for="order">Word Order:</label></th>
  <th><label for="type">Coordination Type:</label></th>
  <th><label for="patt">Pattern:</label></th></tr>
  <tr>
  <td><input list="langs" name="lang" id="lang" placeholder="Search ...">
  <datalist id="langs">
  </datalist>
  </td>
  <td><input list="langfams" name="langfam" id="langfam" placeholder="Search ...">
  <datalist id="langfams">
  </datalist>
  </td>
  <td><select id="feat" name="feat">
    <option value="all">Select All</option>
    <option value="Person">Person</option>
    <option value="Number">Number</option>
    <option value="Gender">Gender</option>
    <option value="Noun Class">Noun Class</option>
   </select></td>
  <td><select id="order" name="order">
    <option value="all">Select All</option>
    <option value="SV">SV</option>
    <option value="VS">VS</option>
   </select></td>
  <td><select id="type" name="type">
    <option value="all">Select All</option>
    <option value="and">And</option>
    <option value="or">Or</option>
   </select></td>
  <td>  <select id="patt" name="patt">
    <option value="all">Select All</option>
    <option value="Ineffability">Ineffability</option>
    <option value="Closest Conjunct Agreement">Closest Conjunct Agreement</option>
    <option value="Resolved Agreement">Resolved Agreement</option>
    <option value="Default Agreement">Default Agreement</option>
    <option value="Syncretism Effects">Syncretism Effects</option>
   </select></td>
  </tr>
  </table>
  <br/>
     <button type="button" name="load_data" id="load_data" class="btn btn-info">Load Data</button>
    </div>
    <br />
    <div id="analysis">
    </div>

    <div id="download">
    </div>

    <div id="language_table">
    </div>
   </div>
  </div>

</body>
</html>

<script>
$(document).ready(function(){
$.ajax({
   url:"https://pwsmith.github.io/multivaluation/language.csv",
   dataType:"text",
   success:function(data)
    {
      //Dynamically add language options and language families from csv-file
      var langs = document.getElementById("langs");
      var langfams = document.getElementById("langfams");
      var row_data = data.split(/\r?\n|\r/);
      var lang_list = new Array("");
      var langfam_list = new Array("");
      for(var count = 1; count<row_data.length; count++)
       {
         var cell_data = row_data[count].split(",");
         var bool_cell_lang = lang_list.includes(cell_data[0]);

         //adds language if language is not already among the options
         if(!bool_cell_lang)
         {
           lang_list.push(cell_data[0]);
         }
         var bool_cell_langfam = langfam_list.includes(cell_data[1]);

         //adds language family if language family is not already among the options
         if(!bool_cell_langfam)
         {
           langfam_list.push(cell_data[1]);
         }
       }

      //adds all language options alphabetically to html code
       lang_list.sort();
       var lang_options = '<option value="Select All">';
      for(var i = 1; i<lang_list.length; i++)
      {
         lang_options += '<option value="'+lang_list[i]+'">';
      }
      $('#langs').html(lang_options);

      //adds all language family options alphabetically to html code
      langfam_list.sort();
      var langfam_options = '<option value="Select All">';
      for(var i = 1; i<langfam_list.length-1; i++)
      {
         langfam_options += '<option value="'+langfam_list[i]+'">';
      }
      $('#langfams').html(langfam_options);
    }
});

$('#load_data').click(function(){
  $.ajax({
   url:"https://pwsmith.github.io/multivaluation/language.csv",
   dataType:"text",
   success:function(data)
   {
    //Get selected language
    var lang = document.getElementById("lang");
    var sel_lang = lang.value.toString();

    //Get selected language family
    var langfam = document.getElementById("langfam");
    var sel_langfam = langfam.value.toString();

    //Get selected agreement feature
    var feat = document.getElementById("feat");
    var sel_feat = feat.options[feat.selectedIndex].value;

    //Get selected word order
    var order = document.getElementById("order");
    var sel_order = order.options[order.selectedIndex].value;

    //Get selected coordination type
    var type = document.getElementById("type");
    var sel_type = type.options[type.selectedIndex].value;

    //Get selected pattern
    var patt = document.getElementById("patt");
    var sel_patt = patt.options[patt.selectedIndex].value;

    var row_data = data.split(/\r?\n|\r/);
    var table_data = '<h2>All results</h2><table class="sortable"><thead>';
    //Head Row
    table_data += '<tr>';
    var cell_data = row_data[0].split(",");
    for(var cell_count=0; cell_count<cell_data.length; cell_count++)
    {
      table_data += '<th>'+cell_data[cell_count]+'</th>';
    }
    table_data += '</tr></thead><tbody>';

    //adds head for csv-file
    var csv = row_data[0]+"\n";

    //----------
    //Counters and strings for analysis
    result_counter = 0; //counts number of results
    lang_array = []; //array for analysis of languages
    langfam_array = []; //array for analysis of language families
    feat_array = []; //array for analysis of agreement features
    order_array = []; //array for analysis of word orders
    type_array = []; //array for analysis of coordination types
    pattern_array = []; //array for analysis of patterns

    //----------
    //Data Rows
    for(var count = 1; count<row_data.length; count++)
    {
     var cell_data = row_data[count].split(",");
     var str_cell_data = cell_data.toString();

     //check whether line matches search
     var bool_feat = str_cell_data.includes(sel_feat);
     var bool_order = str_cell_data.includes(sel_order);
     var bool_type = str_cell_data.includes(","+sel_type+",");
     var bool_patt = str_cell_data.includes(sel_patt);

     //produces line if option is set to Select all or if line contains search term
     if((sel_lang === "Select All" || sel_lang === "" || sel_lang == cell_data[0])
         && (sel_langfam === "Select All" || sel_langfam === "" || sel_langfam == cell_data[1])
         && (sel_feat === "all" || bool_feat)
         && (sel_order === "all" || bool_order)
         && (sel_type === "all" || bool_type)
         && (sel_patt === "all" || bool_patt)
        )
     {
      //adds line to download-file
      csv += row_data[count]+"\n";

      //adds line for website
      table_data += '<tr>';

      //variable for link to language file
      var lang_link = 'https://pwsmith.github.io/multivaluation/coordination/';

      //adds line
      for(var cell_count=0; cell_count<cell_data.length; cell_count++)
      {
       if(cell_count === 0)  //adds language and creates link to language
       {
        lang_link += cell_data[cell_count];

        //removes spaces, brackets, and hyphens in language name and converts to lower case
        lang_link = lang_link.toLowerCase();
        lang_link = lang_link.replace("(", "");
        lang_link = lang_link.replace(")", "");
        lang_link = lang_link.replace(/\-/g, "");
        lang_link = lang_link.split(" ").join("");

        lang_array.push(cell_data[cell_count]);
        table_data += '<td><a href="'+lang_link+'">'+cell_data[cell_count]+'</a></td>';
       }
       if(cell_count === 1)  //adds language family
       {
         langfam_array.push(cell_data[cell_count]);
         table_data += '<td>'+cell_data[cell_count]+'</td>';
       }

       if(cell_count === 2)  //adds agreement feature
       {
         feat_array.push(cell_data[cell_count]);
         table_data += '<td>'+cell_data[cell_count]+'</td>';
       }

       if(cell_count === 3)  //adds word order
       {
         order_array.push(cell_data[cell_count]);
         table_data += '<td>'+cell_data[cell_count]+'</td>';
       }

       if(cell_count === 4)  //adds coordination type
       {
         type_array.push(cell_data[cell_count]);
         table_data += '<td>'+cell_data[cell_count]+'</td>';
       }

       if(cell_count === 5)  //adds pattern
       {
         pattern_array.push(cell_data[cell_count]);
         table_data += '<td>'+cell_data[cell_count]+'</td>';
       }

      }
      table_data += '</tr>';
      result_counter++;
     }

    }
    //----------
    table_data += '</tbody></table>';

    //variables for analysis
    var lang_a = [],
    lang_b = [],
    langfam_a = [],
    langfam_b = [],
    feat_a = [],
    feat_b = [],
    order_a = [],
    order_b = [],
    type_a = [],
    type_b = [],
    pattern_a = [],
    pattern_b = [],
    prev;

    //counts and lists languages
    lang_array.sort();
    for (var i = 0; i < lang_array.length; i++) {
    if (lang_array[i] !== prev) {
      lang_a.push(lang_array[i]);
      lang_b.push(1);
    } else {
      lang_b[lang_b.length - 1]++;
    }
    prev = lang_array[i];
    }

    //counts and lists language families
    langfam_array.sort();
    for (var i = 0; i < langfam_array.length; i++) {
    if (langfam_array[i] !== prev) {
      langfam_a.push(langfam_array[i]);
      langfam_b.push(1);
    } else {
      langfam_b[langfam_b.length - 1]++;
    }
    prev = langfam_array[i];
    }

    //counts and lists agreement features
    feat_array.sort();
    for (var i = 0; i < feat_array.length; i++) {
    if (feat_array[i] !== prev) {
      feat_a.push(feat_array[i]);
      feat_b.push(1);
    } else {
      feat_b[feat_b.length - 1]++;
    }
    prev = feat_array[i];
    }

    //counts and lists word orders
    order_array.sort();
    for (var i = 0; i < order_array.length; i++) {
    if (order_array[i] !== prev) {
      order_a.push(order_array[i]);
      order_b.push(1);
    } else {
      order_b[order_b.length - 1]++;
    }
    prev = order_array[i];
    }

    //counts and lists coordination types
    type_array.sort();
    for (var i = 0; i < type_array.length; i++) {
    if (type_array[i] !== prev) {
      type_a.push(type_array[i]);
      type_b.push(1);
    } else {
      type_b[type_b.length - 1]++;
    }
    prev = type_array[i];
    }

    //counts and lists patterns
    pattern_array.sort();
    for (var i = 0; i < pattern_array.length; i++) {
    if (pattern_array[i] !== prev) {
      pattern_a.push(pattern_array[i]);
      pattern_b.push(1);
    } else {
      pattern_b[pattern_b.length - 1]++;
    }
    prev = pattern_array[i];
    }

    var percent = 0;
    if (result_counter == 1)
    {
      var result = "<h2>Summary</h2><p><b>"+result_counter+" result found:</b></p>";
    }
    else
    {
      var result = "<h2>Summary</h2><p><b>"+result_counter+" results found:</b></p>";
    }

    //writes analysis of languages
    if (lang_a[0] == "")
    {
      var lang_length = lang_a.length-1;
      if (lang_length == 1)
      {
        result += "<ul><li><b>"+lang_length+" language found:</b><br/>";
      }
      else
      {
        result += "<ul><li><b>"+lang_length+" languages found:</b><br/>";
      }
    }
    else
    {
       if (lang_a.length == 1)
      {
        result += "<ul><li><b>"+lang_a.length+" language found:</b><br/>";
      }
      else
      {
        result += "<ul><li><b>"+lang_a.length+" languages found:</b><br/>";
      }
    }

    //adds languages to result string sorted by frequency
    while (lang_a.length > 0)
    {
      //finds the language with the largest number of results;
      var largest = lang_b[0];
      for (var i = 0; i < lang_b.length; i++)
      {
         if (largest < lang_b[i] )
         {
           largest = lang_b[i];
         }
      }
      //finds index of largest number
      var to_pop = lang_b.indexOf(largest);

      //calculates percentage
      percent = (largest/result_counter)*100;
      percent = percent.toFixed(2);

      //creates language link
      var lang_link = 'https://pwsmith.github.io/multivaluation/coordination/'+lang_a[to_pop];
      lang_link = lang_link.toLowerCase();
      lang_link = lang_link.replace("(", "");
      lang_link = lang_link.replace(")", "");
      lang_link = lang_link.replace(/\-/g, "");
      lang_link = lang_link.split(" ").join("");

      //adds language to result string
      if (lang_a.length == 1)
      {
        result += '<a href="'+lang_link+'">'+lang_a[to_pop]+'</a> <small>('+percent+'%)</small>';
      }
      else if (lang_a[to_pop] !== "")
      {
        result += '<a href="'+lang_link+'">'+lang_a[to_pop]+'</a> <small>('+percent+'%)</small>, ';
      }

      //removes found language from sorted language list
      lang_a.splice(to_pop,1);
      lang_b.splice(to_pop,1);
    }

    /*
    for(var i = 0; i < lang_a.length; i++)
    {
      percent = (lang_b[i]/result_counter)*100;
      percent = percent.toFixed(2);
      var lang_link = 'https://pwsmith.github.io/multivaluation/coordination/'+lang_a[i];
      lang_link = lang_link.toLowerCase();
      lang_link = lang_link.replace("(", "");
      lang_link = lang_link.replace(")", "");
      lang_link = lang_link.replace("-", "");
      lang_link = lang_link.split(" ").join("");
      if (i == (lang_a.length-1))
      {
        result += '<a href="'+lang_link+'">'+lang_a[i]+'</a> ('+percent+'%)';
      }
      else if (lang_a[i] !== "")
      {
        result += '<a href="'+lang_link+'">'+lang_a[i]+'</a> ('+percent+'%), ';
      }

    }
    */
    result +="</li>";

    //writes analysis of language families
    if (langfam_a.length == 1)
      {
        result += "<li><b>"+langfam_a.length+" language family found:</b><br/>";
      }
      else
      {
        result += "<li><b>"+langfam_a.length+" language families found:</b><br/>";
      }

    //adds language families to result string sorted by frequency
    while (langfam_a.length > 0)
    {
      //finds the language family with the largest number of results;
      var largest = langfam_b[0];
      for (var i = 0; i < langfam_b.length; i++)
      {
         if (largest < langfam_b[i] )
         {
           largest = langfam_b[i];
         }
      }
      //finds index of largest number
      var to_pop = langfam_b.indexOf(largest);

      //calculates percentage
      percent = (largest/result_counter)*100;
      percent = percent.toFixed(2);

      //adds language family to result string
      if (langfam_a.length == 1)
      {
        result += langfam_a[to_pop]+" <small>("+percent+"%)</small>";
      }
      else if (langfam_a[to_pop] !== "")
      {
        result += langfam_a[to_pop]+" <small>("+percent+"%)</small>, ";
      }

      //removes found language family from sorted language family list
      langfam_a.splice(to_pop,1);
      langfam_b.splice(to_pop,1);
    }

    /*
    for(var i = 0; i < langfam_a.length; i++)
    {
      percent = (langfam_b[i]/result_counter)*100;
      percent = percent.toFixed(2);
      if (i == (langfam_a.length-1))
      {
        result += langfam_a[i]+" ("+percent+"%)";
      }
      else
      {
        result += langfam_a[i]+" ("+percent+"%), ";
      }
    }
    */
    result +="</li>";

    //writes analysis of agreement features
    if (feat_a.length == 1)
    {
        result += "<li><b>"+feat_a.length+" agreement feature found:</b><br/>";
    }
    else
    {
        result += "<li><b>"+feat_a.length+" agreement features found:</b><br/>";
    }

    //adds features to result string sorted by frequency
    while (feat_a.length > 0)
    {
      //finds the features with the largest number of results;
      var largest = feat_b[0];
      for (var i = 0; i < feat_b.length; i++)
      {
         if (largest < feat_b[i] )
         {
           largest = feat_b[i];
         }
      }
      //finds index of largest number
      var to_pop = feat_b.indexOf(largest);

      //calculates percentage
      percent = (largest/result_counter)*100;
      percent = percent.toFixed(2);

      //adds feature to result string
      if (feat_a.length == 1)
      {
        result += feat_a[to_pop]+" <small>("+percent+"%)</small>";
      }
      else if (feat_a[to_pop] !== "")
      {
        result += feat_a[to_pop]+" <small>("+percent+"%)</small>, ";
      }

      //removes found feature from sorted feature list
      feat_a.splice(to_pop,1);
      feat_b.splice(to_pop,1);
    }
    /*
    for(var i = 0; i < feat_a.length; i++)
    {
      percent = (feat_b[i]/result_counter)*100;
      percent = percent.toFixed(2);
      if (i == (feat_a.length-1))
      {
        result += feat_a[i]+" ("+percent+"%) ";
      }
      else
      {
        result += feat_a[i]+" ("+percent+"%), ";
      }
    }
    */
    result +="</li>";

    //writes analysis of word orders
    if (order_a.length == 1)
    {
        result += "<li><b>"+order_a.length+" word order found:</b><br/>";
    }
    else
    {
        result += "<li><b>"+order_a.length+" word orders found:</b><br/>";
    }

    //adds word orders to result string sorted by frequency
    while (order_a.length > 0)
    {
      //finds the orders with the largest number of results;
      var largest = order_b[0];
      for (var i = 0; i < order_b.length; i++)
      {
         if (largest < order_b[i] )
         {
           largest = order_b[i];
         }
      }
      //finds index of largest number
      var to_pop = order_b.indexOf(largest);

      //calculates percentage
      percent = (largest/result_counter)*100;
      percent = percent.toFixed(2);

      //adds word order to result string
      if (order_a.length == 1)
      {
        result += order_a[to_pop]+" <small>("+percent+"%)</small>";
      }
      else if (order_a[to_pop] !== "")
      {
        result += order_a[to_pop]+" <small>("+percent+"%)</small>, ";
      }

      //removes found word order from sorted word order list
      order_a.splice(to_pop,1);
      order_b.splice(to_pop,1);
    }
    /*
    for(var i = 0; i < order_a.length; i++)
    {
      percent = (order_b[i]/result_counter)*100;
      percent = percent.toFixed(2);
      if (i == (order_a.length-1))
      {
        result += order_a[i]+" ("+percent+"%)";
      }
      else
      {
        result += order_a[i]+" ("+percent+"%), ";
      }
    }
    */
    result +="</li>";

    //writes analysis of coordination type
    if (type_a.length == 1)
    {
        result += "<li><b>"+type_a.length+" coordination type found:</b><br/>";
    }
    else
    {
        result += "<li><b>"+type_a.length+" coordination types found:</b><br/>";
    }

    //adds coordination type to result string sorted by frequency
    while (type_a.length > 0)
    {
      //finds the type with the largest number of results;
      var largest = type_b[0];
      for (var i = 0; i < type_b.length; i++)
      {
         if (largest < type_b[i] )
         {
           largest = type_b[i];
         }
      }
      //finds index of largest number
      var to_pop = type_b.indexOf(largest);

      //calculates percentage
      percent = (largest/result_counter)*100;
      percent = percent.toFixed(2);

      //adds type to result string
      if (type_a.length == 1)
      {
        result += type_a[to_pop]+" <small>("+percent+"%)</small>";
      }
      else if (type_a[to_pop] !== "")
      {
        result += type_a[to_pop]+" <small>("+percent+"%)</small>, ";
      }

      //removes found type from sorted type list
      type_a.splice(to_pop,1);
      type_b.splice(to_pop,1);
    }
    /*
    for(var i = 0; i < type_a.length; i++)
    {
      percent = (type_b[i]/result_counter)*100;
      percent = percent.toFixed(2);
      if (i == (type_a.length-1))
      {
        result += type_a[i]+" ("+percent+"%)";
      }
      else
      {
        result += type_a[i]+" ("+percent+"%), ";
      }
    }
    */
    result +="</li>";

    //writes analysis of pattern
    if (pattern_a.length == 1)
    {
        result += "<li><b>"+pattern_a.length+" pattern found:</b><br/>";
    }
    else
    {
        result += "<li><b>"+pattern_a.length+" patterns found:</b><br/>";
    }

    //adds pattern to result string sorted by frequency
    while (pattern_a.length > 0)
    {
      //finds the pattern with the largest number of results;
      var largest = pattern_b[0];
      for (var i = 0; i < pattern_b.length; i++)
      {
         if (largest < pattern_b[i] )
         {
           largest = pattern_b[i];
         }
      }
      //finds index of largest number
      var to_pop = pattern_b.indexOf(largest);

      //calculates percentage
      percent = (largest/result_counter)*100;
      percent = percent.toFixed(2);

      //adds pattern to result string
      if (pattern_a.length == 1)
      {
        result += pattern_a[to_pop]+" <small>("+percent+"%)</small>";
      }
      else if (pattern_a[to_pop] !== "")
      {
        result += pattern_a[to_pop]+" <small>("+percent+"%)</small>, ";
      }

      //removes found pattern from sorted pattern list
      pattern_a.splice(to_pop,1);
      pattern_b.splice(to_pop,1);
    }
    /*
    for(var i = 0; i < pattern_a.length; i++)
    {
      percent = (pattern_b[i]/result_counter)*100;
      percent = percent.toFixed(2);
      if (i == (pattern_a.length-1))
      {
        result += pattern_a[i]+" ("+percent+"%)";
      }
      else
      {
        result += pattern_a[i]+" ("+percent+"%), ";
      }
    }
    */
    result +="</li>";
    result += "</ul>";

    //creates string for txt-file to download
    var result_file = result;
    result_file = result_file.replace("<h2>Summary</h2><p><b>", "");
    result_file = result_file.replace("</b></p>", "\n\n");
    result_file = result_file.replace("<ul><li><b>", "");
    result_file = result_file.replace(/\<li\>\<b\>/g, "");
    result_file = result_file.replace(/\<\/b\>\<br\/\>/g, "\n-  ");
    result_file = result_file.replace(/https\:\/\/pwsmith\.github\.io\/multivaluation\/coordination\//g, "");
    result_file = result_file.replace(/\<a\ href\=\"\w{0,100}\"\>/g, "");
    result_file = result_file.replace(/<\/a>\ <small>/g, " ");
    result_file = result_file.replace(/<small>/g, "");
    result_file = result_file.replace(/<\/small>\u002C/g, "\n- ");
    result_file = result_file.replace(/<\/small><\/li>/g, "\n\n");
    result_file = result_file.replace("</ul>", "");

    /*
    result_file = result_file.replace(/<\w{0,5}>/g, "");
    result_file = result_file.replace(/<\/?\w{0,5}>/g, "\n\n");
    */

    //saves results and creates download link for analysis
    console.log(result_file);
    var href = 'data:text/csv;charset=utf-8,' + encodeURI(result_file);
    var download = '<br/><p><a href = "'+href+'" target = "_blank" download="result.txt">Download summary</a> ';

    //saves table and creates download link for table
    console.log(csv);
    href = 'data:text/csv;charset=utf-8,' + encodeURI(csv);
    download += ' <a href = "'+href+'" target = "_blank" download="table.csv">Download the table with all results</a><br/></p>';


    if(result_counter > 0)
    {
      document.getElementById('download').innerHTML = download;
      document.getElementById('analysis').innerHTML = result;
      document.getElementById('language_table').innerHTML = table_data;
    }
    else
    {
      $('#analysis').html("No results found.");
      $('#language_table').html("");

    }
      //clears search fields after printing results
      $('input[name=lang]').val('');
      $('input[name=langfam]').val('');
      result_counter = 0;
      download = "";
   }
  });
 });

});

</script>
